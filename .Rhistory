0,0,0,1,0,2,
0,0,0,0,1,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_2r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain multi-rate model
D<-matrix(c(
0,6,0,0,0,0,
1,0,7,0,0,0,
0,2,0,8,0,0,
0,0,3,0,9,0,
0,0,0,4,0,10,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_10r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain + jump model
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_jump<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## compare among all fitted models (sorted by complexity)
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
## from this we see evidence that we FAILED to converge to the
## true MLEs for our two most complex models. Why do I think that?
## let's run multiple optimization iterations in parallel
## load required packages
library(foreach)
library(doParallel)
niter<-30 ## number of iterations
ncores<-min(niter,detectCores()-4) ## number of cores (leave 4 free)
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)
## loss/gain multi-rate model design matrix
D<-matrix(c(
0,6,0,0,0,0,
1,0,7,0,0,0,
0,2,0,8,0,0,
0,0,3,0,9,0,
0,0,0,4,0,10,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgain10r_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgain10r_fits,logLik)
lnL
## new best model
squamate_lossgain_10r<-lossgain10r_fits[[which.max(lnL)]]
## loss/gain + jump design matrix
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgainjump_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgainjump_fits,logLik)
lnL
## new best model
squamate_lossgain_jump<-lossgainjump_fits[[which.max(lnL)]]
## stop cluster
stopCluster(cl=mc)
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
squamate_lossgain_jump
squamate_lossgain_10r
niter<-30 ## number of iterations
ncores<-min(niter,detectCores()-4) ## number of cores (leave 4 free)
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)
lossgainjump_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=FALSE) #sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgainjump_fits,logLik)
lnL
## new best model
squamate_lossgain_jump<-lossgainjump_fits[[which.max(lnL)]]
## stop cluster
stopCluster(cl=mc)
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
squamate_lossgain_jump
lnL
niter<-30 ## number of iterations
ncores<-min(niter,detectCores()-4) ## number of cores (leave 4 free)
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)
## loss/gain + jump design matrix
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgainjump_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=TRUE)
}
## get log-likelihoods
lnL<-sapply(lossgainjump_fits,logLik)
lnL
## new best model
squamate_lossgain_jump<-lossgainjump_fits[[which.max(lnL)]]
## stop cluster
stopCluster(cl=mc)
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
lnL
save.image("C:/Users/liamj/Dropbox/courses/BIOL634-fall2025/hw/4/hw4-solution.RData")
library(geiger)
tree<-pbtree(n=10)
x<-sim.char(tree)
x<-sim.char(tree,par=list(sigma=0.5))
x<-sim.char(tree,par=0.5)
x
?sim.char
?rTraitCont
?fastBM
?fastBM
tree<-pbtree(n=100,scale=1)
x<-fastBM(tree,alpha=1)
x<-fastBM(tree,alpha=1,theta=0)
geiger::fitContinuous(tree,x)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=500,scale=1)
x<-fastBM(tree,alpha=1,theta=0)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=1000,scale=1)
x<-fastBM(tree,alpha=0.5,theta=0)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=2000,scale=1)
x<-fastBM(tree,alpha=0.5,theta=0)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=2000,scale=1)
x<-fastBM(tree,alpha=0.8,theta=0)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=5000,scale=1)
x<-fastBM(tree,alpha=0.8,theta=0)
geiger::fitContinuous(tree,x,model="OU")
tree<-pbtree(N=100,b=1,d=0.3)
tree<-pbtree(n=100,b=1,d=0.3)
tree
library(phangorn)
howmanytrees()
howmanytrees(10)
howmanytrees(20)
?howmanytrees
phangorn::howmanytrees(n=15)
## load packages
library(phytools)
library(geiger)
## load some data
data("cordylid.tree")
## plot this tree
plotTree(cordylid.tree,ftype="i")
## plot this tree
plotTree(cordylid.tree,ftype="i",fsize=0.9)
args(nodelabels)
nodelabels(cex=0.6,frame="circle",bg="white")
## load in my data
data("cordylid.data")
head(cordylid.data)
##
cordylid_armoring<-setNames(cordylid.data$pPC1,
rownames(cordylid.data))
cordylid_armoring
## estimate ML ancestral states using fastAnc
cordylid_ml<-fastAnc(cordylid.tree,cordylid_armoring)
cordylid_ml
## estimate ML ancestral states using fastAnc
cordylid_ml<-fastAnc(cordylid.tree,cordylid_armoring,
CI=TRUE)
cordylid_ml
## compare 95% CI on root to range of trait
range(cordylid_armoring)
## visualize our reconstruction using contMap
cordylid_cmap<-contMap(cordylid.tree,cordylid_armoring,
plot=FALSE)
cordylid_cmap
plot(cordylid_cmap)
plot(cordylid_cmap,fsize=0.8)
## update our color gradient
cordylid_cmap<-setMap(cordylid_cmap,hcl.colors(n=100))
plot(cordylid_cmap,fsize=0.8)
nodelabels(cex=0.6,frame="circle",bg="white")
## let's Bayesian MCMC ancestral state reconstruction
cordylid_mcmc<-anc.Bayes(cordylid.tree,
cordylid_armoring,ngen=500000)
anc.Bayes
## informative prior on the root
Prior_mean<-c(1000,min(cordylid_armoring),
rep(mean(cordylid_armoring,cordylid.tree$Nnode)))
Prior_mean
## informative prior on the root
Prior_mean<-c(1000,min(cordylid_armoring),
rep(mean(cordylid_armoring),cordylid.tree$Nnode))
Prior_mean
var(cordylid_armoring)
Prior_var<-c(1e6,0.25,rep(1000,cordylid.tree$Nnode-1))
cordylid_mcmc.informative<-anc.Bayes(cordylid.tree,
cordylid_armoring,ngen=500000,
control=list(pr.mean=Prior_mean,pr.var=Prior_var))
cordylid_mcmc.informative$ace
cordylid_mcmc.informative
Prior_var<-c(1e6,0.01,rep(1000,cordylid.tree$Nnode-1))
cordylid_mcmc.informative<-anc.Bayes(cordylid.tree,
cordylid_armoring,ngen=500000,
control=list(pr.mean=Prior_mean,pr.var=Prior_var))
cordylid_mcmc.informative
cordyld_mcmc
cordylid_mcmc
dev.off()
cordylid_ml
str(cordylid_mcmc)
obj<-print(cordylid_mcmc)
str(obj)
plot(cordylid_ml$ace,obj)
plot(cordylid_ml$ace,obj,bty="n",pch=21,pt.bg="grey",
xlab="ML estimates",ylab="Bayesian estimates")
plot(cordylid_ml$ace,obj,bty="n",pch=21,bg="grey",
xlab="ML estimates",ylab="Bayesian estimates")
plot(cordylid_ml$ace,obj,bty="n",pch=21,bg="grey",
xlab="ML estimates",ylab="Bayesian estimates",
las=1)
grid()
min(cordylid_armoring)
cordylid.tree$Nnode
## let's specify an informative prior
Prior_mean<-c(
1000,
min(cordylid_armoring),
rep(mean(cordylid_armoring),cordylid.tree$Nnode-1))
var(cordylid_armoring)
Prior_var<-c(
1e6,
0.01,
rep(1000,cordylid.tree$Nnode-1))
cordylid_mcmc.informative<-anc.Bayes(cordylid.tree,
cordylid_armoring,ngen=500000,
control=list(pr.mean=Prior_mean,
pr.var=Prior_var))
cordylid_mcmc.informative
obj<-print(cordylid_mcmc.informative)
plot(cordylid_ml$ace,obj,bty="n",pch=21,bg="grey",
xlab="ML estimates",ylab="Bayesian estimates (informative prior)",
las=1)
grid()
cordylid_cmap.bayes<-contMap(cordylid_tree,
cordylid_armoring,anc.states=obj$ace,plot=FALSE)
cordylid_cmap.bayes<-contMap(cordylid.tree,
cordylid_armoring,anc.states=obj$ace,plot=FALSE)
cordylid_cmap.bayes<-contMap(cordylid.tree,
cordylid_armoring,anc.states=obj$ace,plot=FALSE)
cordylid_cmap.bayes<-setMap(cordylid_cmap.bayes,
hcl.colors(n=100))
plot(cordylid_cmap.bayes,fsize=0.8)
cordylid_cmap.bayes<-contMap(cordylid.tree,
cordylid_armoring,anc.states=obj,plot=FALSE)
cordylid_cmap.bayes<-setMap(cordylid_cmap.bayes,
hcl.colors(n=100))
plot(cordylid_cmap.bayes,fsize=0.8)
dev.off()
obj<-print(cordylid_mcmc.informative)
plot(cordylid_ml$ace,obj,bty="n",pch=21,bg="grey",
xlab="ML estimates",ylab="Bayesian estimates (informative prior)",
las=1)
grid()
cordylid_cmap.bayes<-contMap(cordylid.tree,
cordylid_armoring,anc.states=obj,plot=FALSE)
cordylid_cmap.bayes<-setMap(cordylid_cmap.bayes,
hcl.colors(n=100))
plot(cordylid_cmap.bayes,fsize=0.8)
cordylid_cmap.bayes<-contMap(cordylid.tree,
cordylid_armoring,method="user",
anc.states=obj,plot=FALSE)
cordylid_cmap.bayes<-setMap(cordylid_cmap.bayes,
hcl.colors(n=100))
plot(cordylid_cmap.bayes,fsize=0.8)
plot(cordylid_cmap,ftype="off")
par(mfrow=c(1,2))
plot(cordylid_cmap,ftype="off")
plot(cordylid_cmap.bayes,ftype="off",
direction="leftwards")
plot(cordylid_cmap,ftype="off",fsize=0.6)
plot(cordylid_cmap.bayes,ftype="off",
direction="leftwards",fsize=0.6)
dev.off()
plot(cordylid_cmap.bayes,ftype="off",
direction="leftwards",fsize=0.6)
plot(cordylid_cmap.bayes,ftype="off",
direction="rightwards",fsize=0.6)
nodelabels(frame="circle",cex=0.6)
cordylid_node.42<-density(cordylid_mcmc.informative,what=42)
dev.off()
plot(cordylid_node.42)
cordylid_node.42
## load primate data
data(primate.tree)
data(primate.data)
## pull out our character
activity<-setNames(primate.data$Activity_pattern,
rownames(primate.data))
activity
## fit three models: ER, SYM, ARD models
er_primates<-fitMk(primate.tree,activity,
model="ER")
sym_primates<-fitMk(primate.tree,activity,
model="SYM")
ard_primates<-fitMk(primate.tree,activity,
model="ARD")
## traditionally, we would compare these three
## models and choose the "best"
anova(er_primates,
sym_primates,
ard_primates)
## estimate marginal ancestral states under
## "best" (i.e., ER) model
primate_er.marginal<-ancr(er_primates)
primate_er.marginal
## we can plot this
plot(primate_er.marginal)
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards"))
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards"),
args.nodelabels=list(piecol=c("yellow","pink","purple")))
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards"),
args.nodelabels=list(piecol=c("pink","yellow","purple")))
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards"),
args.nodelabels=list(piecol=c("pink","yellow","navy")))
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards"),
args.nodelabels=list(piecol=c("pink","gold","navy")))
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards",type="fan"),
args.nodelabels=list(piecol=c("pink","gold","navy")))
## we can plot this
plot(primate_er.marginal,
args.plotTree=list(direction="upwards"),
args.nodelabels=list(piecol=c("pink","gold","navy")))
## re-calculate our model comparison
anova(er_primates,
sym_primates,
ard_primates)->aov_primates
aov_primates
primate_modelaveraged.marginal<-ancr(aov_primates)
primate_modelaveraged.marginal
plot(primate_modelaveraged.marginal,
args.plotTree=list(direction="upwards"),
args.nodelabels=list(piecol=c("pink","gold","navy")))
setwd("courses/Israel-2025/work")
## download salamanders.nex file
download.file(
url="https://liamrevell.github.io/hula2025/data/salamanders.nex",
destfile="salamanders.nex")
## load phytools package
library(phytools)
## read in my phylogeny
salamander_tree<-read.nexus(file="salamanders.nex")
salamander_tree
## let's plot our salamander tree
plotTree(salamander_tree,ftype="i",fsize=0.9)
## the first thing that we can do is create
## a lineage-through-time plot
salamander_ltt<-ltt(salamander_tree,plot=FALSE)
salamander_ltt
## plot it
dev.off()
plot(salamander_ltt)
plot(salamander_ltt,log.lineages=FALSE)
plot(salamander_ltt,log.lineages=FALSE,log="y")
plot(salamander_ltt,log.lineages=FALSE,log="y",
show.tree=TRUE)
plot(salamander_ltt,log.lineages=FALSE,log="y",
show.tree=TRUE,lwd=2)
salamander_ltt
## fit birth-death model
salamander_bd<-fit.bd(salamander_tree)
salamander_bd
Ntips(salamander_tree)
Ntip(salamander_tree)
plethodon_rho<-Ntip(salamander_tree)/n_plethodon
## how many Plethodon species are there
n_plethodon<-58
plethodon_rho<-Ntip(salamander_tree)/n_plethodon
plethodon_rho
## re-fit our model accounting for this rho
salamander_bd.sampling<-fit.bd(salamander_tree,
rho=plethodon_rho)
salamander_bd.sampling
salamander_bd
## install diversitree
install.packages("diversitree")
## load diversitree package
library(diversitree)
## create birth-death likelihood function for our
## salamander_tree object
salamander_bd_fn<-make.bd(salamander_tree,
sampling.f=plethodon_rho)
args(salamander_bd_fn)
## take our fitted BD model from phytools
salamander_bd.sampling
salamander_bd_fn(pars=c(0.02082,0.016))
?find.mle
## now let's actually optimize this model
salamander_bd.fitted<-find.mle(salamander_bd_fn,
x.init=c(1,0.1),method="optim",lower=c(0,0))
salamander_bd.fitted
## fit a BiSSE model!
grunts_data<-read.csv(
file="https://liamrevell.github.io/hula2025/data/grunts.csv",
row.names=1)
grunts_data
grunts_tree<-read.tree(
file="https://liamrevell.github.io/hula2025/data/grunts.phy")
grunts_tree
?make.bisse
## let's make a likelihood function!
grunts_habitat<-setNames(grunts_data$habitat,
rownames(grunts_data))
head(grunts_habitat)
grunts_bisse_fn<-make.bisse(grunts_tree,
states=grunts_habitat)
grunts_bisse_fn
## find a reasonable starting point for optimization
?starting.point.bisse
grunts_init<-starting.point.bisse(grunts_tree)
grunts_init
Ntip(grunts_tree)
grunts_bisse_fn.fitted<-find.mle(grunts_bisse_fn,
x.init=grunts_init)
grunts_bisse_fn.fitted
getwd()
setwd("../hula2025/")
list.files("data")
list.files()
list.files("data")
