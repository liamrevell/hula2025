## let's make it look a little nicer
plotTree(rooted.nj_tree)
nodelabels(bs/100,adj=c(1.2,1.2),cex=0.9,frame="none")
## we could've skipped all this....
plotBS(rooted.nj_tree,rooted.bs_trees)
## clean up our workspace
rm(list=ls())
## let's make a function for all this
njBoot<-function(dna,nrep=100,outgroup){
nsites<-ncol(dna)
foo<-function(X,nsites) X[,sample(1:nsites,replace=TRUE)]
bs_dna<-replicate(nrep,foo(dna,nsites),simplify=FALSE)
rooted.nj_tree<-root(NJ(dist.dna(dna,model="JC69")),
outgroup=outgroup,resolve.root=TRUE)
foo<-function(X) root(NJ(dist.dna(X,model="JC69")),
outgroup=outgroup,resolve.root=TRUE)
rooted.bs_trees<-lapply(bs_dna,foo)
bs<-prop.clades(rooted.nj_tree,rooted.bs_trees)
plotTree(rooted.nj_tree,lwd=1)
nodelabels(bs/100,adj=c(1.2,1.2),cex=0.9,frame="none")
rooted.nj_tree$node.label<-bs/100
return(rooted.nj_tree)
}
## we can run a test on our original dataset
XX<-read.dna(file=
"https://liamrevell.github.io/biol634/data/primates.dna")
njBoot(XX,outgroup="Lemur")->bootstrapped_tree
## now let's do it with the Jackman et al. data
## (we read it in using phangorn::read.phyDat to more easily convert
## to "DNAbin" in matrix)
YY<-read.phyDat(
file="https://liamrevell.github.io/biol634/data/Jackman-etal.nex",
format="nexus")
YY<-as.DNAbin(YY)
njBoot(YY,outgroup="Diplolaemus_darwinii")
20*exp(0.3*20)
20*exp(0.1*20)
20*exp(0.3*10)
20*exp(0.3*20)
20*exp(20*0.3)
exp(20*0.3)
10*exp(20*0.3)
log(2)/0.1
log(4000/20)/20
log(2)/0.27
## homework details: https://liamrevell.github.io/biol634/hw/4/hw4-problem.html
## load packages
library(phytools)
library(geiger)
## in class we loaded & cleaned up the data as follows
## load data
squamate_data<-read.csv(
file="https://liamrevell.github.io/biol634/data/brandley_table.csv",
row.names=1)
## load tree
squamate_tree<-read.nexus(
file="https://liamrevell.github.io/biol634/data/squamate.tre")
## gsub " " for "_" in species labels of data
rownames(squamate_data)<-gsub(" ","_",rownames(squamate_data))
## still a name mismatch
name.check(squamate_tree,squamate_data)
## subsample squamate_data
squamate_data<-squamate_data[squamate_tree$tip.label,]
## pull out hind digits & round
hind_digits<-setNames(squamate_data$Toes,
rownames(squamate_data))
hind_digits<-round(hind_digits)
## fit ER model
squamate_er<-fitMk(squamate_tree,hind_digits,model="ER",
pi="fitzjohn")
## fit 1-rate loss-only model
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
0,1,0,0,0,0,
0,0,1,0,0,0,
0,0,0,1,0,0,
0,0,0,0,1,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossonly_1r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss-only multi-rate model
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
0,2,0,0,0,0,
0,0,3,0,0,0,
0,0,0,4,0,0,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossonly_5r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit ordered + jump model
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
6,2,0,0,0,0,
6,0,3,0,0,0,
6,0,0,4,0,0,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossonly_jump<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain two-rate model
D<-matrix(c(
0,2,0,0,0,0,
1,0,2,0,0,0,
0,1,0,2,0,0,
0,0,1,0,2,0,
0,0,0,1,0,2,
0,0,0,0,1,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_2r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain multi-rate model
D<-matrix(c(
0,6,0,0,0,0,
1,0,7,0,0,0,
0,2,0,8,0,0,
0,0,3,0,9,0,
0,0,0,4,0,10,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_10r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain + jump model
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_jump<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## compare among all fitted models (sorted by complexity)
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
## from this we see evidence that we FAILED to converge to the
## true MLEs for our two most complex models. Why do I think that?
## let's run multiple optimization iterations in parallel
## load required packages
library(foreach)
library(doParallel)
niter<-20 ## number of iterations
ncores<-min(niter,detectCores()-4) ## number of cores (leave 4 free)
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)
## loss/gain multi-rate model design matrix
D<-matrix(c(
0,6,0,0,0,0,
1,0,7,0,0,0,
0,2,0,8,0,0,
0,0,3,0,9,0,
0,0,0,4,0,10,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgain10r_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgain10r_fits,logLik)
lnL
## new best model
squamate_lossgain_10r<-lossgain10r_fits[[which.max(lnL)]]
## loss/gain + jump design matrix
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgainjump_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgainjump_fits,logLik)
lnL
## new best model
squamate_lossgain_jump<-lossgainjump_fits[[which.max(lnL)]]
## stop cluster
stopCluster(cl=mc)
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
lnL
squamate_lossgain_10r
squamate_lossgain_jump
squamate_lossgain_10r
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
length(lnL0)
length(lnL)
## homework details: https://liamrevell.github.io/biol634/hw/4/hw4-problem.html
## load packages
library(phytools)
library(geiger)
## in class we loaded & cleaned up the data as follows
## load data
squamate_data<-read.csv(
file="https://liamrevell.github.io/biol634/data/brandley_table.csv",
row.names=1)
## load tree
squamate_tree<-read.nexus(
file="https://liamrevell.github.io/biol634/data/squamate.tre")
## gsub " " for "_" in species labels of data
rownames(squamate_data)<-gsub(" ","_",rownames(squamate_data))
## still a name mismatch
name.check(squamate_tree,squamate_data)
## subsample squamate_data
squamate_data<-squamate_data[squamate_tree$tip.label,]
## pull out hind digits & round
hind_digits<-setNames(squamate_data$Toes,
rownames(squamate_data))
hind_digits<-round(hind_digits)
## fit ER model
squamate_er<-fitMk(squamate_tree,hind_digits,model="ER",
pi="fitzjohn")
## fit 1-rate loss-only model
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
0,1,0,0,0,0,
0,0,1,0,0,0,
0,0,0,1,0,0,
0,0,0,0,1,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossonly_1r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss-only multi-rate model
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
0,2,0,0,0,0,
0,0,3,0,0,0,
0,0,0,4,0,0,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossonly_5r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit ordered + jump model
D<-matrix(c(
0,0,0,0,0,0,
1,0,0,0,0,0,
6,2,0,0,0,0,
6,0,3,0,0,0,
6,0,0,4,0,0,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossonly_jump<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain two-rate model
D<-matrix(c(
0,2,0,0,0,0,
1,0,2,0,0,0,
0,1,0,2,0,0,
0,0,1,0,2,0,
0,0,0,1,0,2,
0,0,0,0,1,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_2r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain multi-rate model
D<-matrix(c(
0,6,0,0,0,0,
1,0,7,0,0,0,
0,2,0,8,0,0,
0,0,3,0,9,0,
0,0,0,4,0,10,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_10r<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## fit loss/gain + jump model
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
squamate_lossgain_jump<-fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn")
## compare among all fitted models (sorted by complexity)
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
## from this we see evidence that we FAILED to converge to the
## true MLEs for our two most complex models. Why do I think that?
## let's run multiple optimization iterations in parallel
## load required packages
library(foreach)
library(doParallel)
niter<-30 ## number of iterations
ncores<-min(niter,detectCores()-4) ## number of cores (leave 4 free)
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)
## loss/gain multi-rate model design matrix
D<-matrix(c(
0,6,0,0,0,0,
1,0,7,0,0,0,
0,2,0,8,0,0,
0,0,3,0,9,0,
0,0,0,4,0,10,
0,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgain10r_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgain10r_fits,logLik)
lnL
## new best model
squamate_lossgain_10r<-lossgain10r_fits[[which.max(lnL)]]
## loss/gain + jump design matrix
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgainjump_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgainjump_fits,logLik)
lnL
## new best model
squamate_lossgain_jump<-lossgainjump_fits[[which.max(lnL)]]
## stop cluster
stopCluster(cl=mc)
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
squamate_lossgain_jump
squamate_lossgain_10r
niter<-30 ## number of iterations
ncores<-min(niter,detectCores()-4) ## number of cores (leave 4 free)
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)
lossgainjump_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=FALSE) #sample(c(TRUE,FALSE),1))
}
## get log-likelihoods
lnL<-sapply(lossgainjump_fits,logLik)
lnL
## new best model
squamate_lossgain_jump<-lossgainjump_fits[[which.max(lnL)]]
## stop cluster
stopCluster(cl=mc)
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
squamate_lossgain_jump
lnL
niter<-30 ## number of iterations
ncores<-min(niter,detectCores()-4) ## number of cores (leave 4 free)
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)
## loss/gain + jump design matrix
D<-matrix(c(
0,7,0,0,0,0,
1,0,8,0,0,0,
6,2,0,9,0,0,
6,0,3,0,10,0,
6,0,0,4,0,11,
6,0,0,0,5,0),
6,6,byrow=TRUE,
dimnames=list(0:5,0:5))
lossgainjump_fits<-foreach(i=1:niter)%dopar%{
phytools::fitMk(squamate_tree,hind_digits,
model=D,pi="fitzjohn",rand_start=TRUE,
lik.func="lik",logscale=TRUE)
}
## get log-likelihoods
lnL<-sapply(lossgainjump_fits,logLik)
lnL
## new best model
squamate_lossgain_jump<-lossgainjump_fits[[which.max(lnL)]]
## stop cluster
stopCluster(cl=mc)
## re-run comparison
anova(
squamate_er,
squamate_lossonly_1r,
squamate_lossgain_2r,
squamate_lossonly_5r,
squamate_lossonly_jump,
squamate_lossgain_10r,
squamate_lossgain_jump)
lnL
save.image("C:/Users/liamj/Dropbox/courses/BIOL634-fall2025/hw/4/hw4-solution.RData")
library(geiger)
tree<-pbtree(n=10)
x<-sim.char(tree)
x<-sim.char(tree,par=list(sigma=0.5))
x<-sim.char(tree,par=0.5)
x
?sim.char
?rTraitCont
?fastBM
?fastBM
tree<-pbtree(n=100,scale=1)
x<-fastBM(tree,alpha=1)
x<-fastBM(tree,alpha=1,theta=0)
geiger::fitContinuous(tree,x)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=500,scale=1)
x<-fastBM(tree,alpha=1,theta=0)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=1000,scale=1)
x<-fastBM(tree,alpha=0.5,theta=0)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=2000,scale=1)
x<-fastBM(tree,alpha=0.5,theta=0)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=2000,scale=1)
x<-fastBM(tree,alpha=0.8,theta=0)
geiger::fitContinuous(tree,x,model="OU")
?rTraitCont
?fastBM
tree<-pbtree(n=5000,scale=1)
x<-fastBM(tree,alpha=0.8,theta=0)
geiger::fitContinuous(tree,x,model="OU")
tree<-pbtree(N=100,b=1,d=0.3)
tree<-pbtree(n=100,b=1,d=0.3)
tree
library(phangorn)
howmanytrees()
howmanytrees(10)
howmanytrees(20)
?howmanytrees
phangorn::howmanytrees(n=15)
getwd()
setwd("courses/Israel-2025/hula2025/")
list.files
